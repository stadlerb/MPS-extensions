{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"table tbody tr td:nth-child(2) { color: limegreen; } table tbody tr + tr td:nth-child(2) { color: orange; } table tbody tr + tr + tr td:nth-child(2) { color: orange; } table tbody tr + tr + tr + tr td:nth-child(2) { color: tomato; } Welcome to the MPS Extensions The MPS extensions aim to ease language development within MPS. They are maintained by itemis, JetBrains and the open source community and its development is closely related to the development of MPS. MPS Extensions and mbeddr (platform) How is the relationship between the mbeddr (platform) and this project? The mbeddr project in the past developed a set of extensions that where used to allow easier development of languages with MPS. These extensions where not C specific and were called mbeddr platform . This project aims to give these extensions a new home. To make them more visible but also emphasise that these extensions are independent of mbeddr and it's C implementation in MPS. The midterm goal is to migrate most of these extensions in this project. Not all of them will really fit here because some of these are very experimental or have very specific use cases. Our goal is to migrate the stable bits first. See the migration section of the documentation on what we plan to migrate at the moment and how you could help. Getting Started To get started grab a release from our release page on github . Extract the archive and point a project or global library in MPS to the location where you extracted it. See the documentation regarding the individual extensions above. The documentation is \"currently work in progress\" as it being ported over from the mbeddr platform repository. Documentation related contributions are very welcome! We are also working on providing a zip file with all the sandboxes we have in our repository in order to try things out and see how the extensions work. See this issue for details . Artefacts in the Nexus We also provide the artefacts as a maven repository. Where you can fetch them during your CI build to setup your local development environment. Maven: project ... repositories repository id itemis.mbeddr /id url https://projects.itemis.de/nexus/content/repositories/mbeddr /url /repository /repositories dependencies ... dependency groupId de.itemis.mps /groupId artifactId extensions /artifactId version 2018.2 /version type zip /type /dependency /dependencies /project Gradle: repositories { maven { url 'https://projects.itemis.de/nexus/content/repositories/mbeddr' } } configurations { mpsExtensions } dependencies { mpsExtensions de.itemis.mps:extensions:2018.2.+ } Versions The version number reflects the MPS version the extensions are compatible with. For instance 2018.1.X is compatible with MPS 2018.1, 2017.3.X is compatible with MPS 2017.3.6. We only maintain compatibility with the latest minor release for each major version. While a 2017.3.x version of the extension might work with a on older version than MPS 2017.3.6 we only test it against the latest. Current Versions Currently these MPS versions are supported. Versions prior to MPS 2017.3 might still be available as the mbeddr platform but are not maintained in the repository. A version in maintenance will not get actively new features and is only maintained with bugfixes. We are happy to accept pull request for versions in maintenance with bugfixes but active feature development only happens for the latest MPS version. MPS Version State 2018.2 active development 2018.1 maintenance 2017.3 maintenance 2017.2 not maintained 2017.1 not maintained Grammar Cells Migration Starting from version 2018.2.348 the MPS extensions also contain grammar cells which have been ported over from the mbeddr platform. For users of grammar cells this is mostly a transparent change since the mbeddr platform currently repackages the MPS extensions. This means that if you are using the mbeddr platform today you should not have to do much manual work. mbeddr changes The most obvious change here is that the version of the mbeddr artefacts was incremented by a minor. That means you will have to adjust your build files to get the version 1.1+ instead of 1.0* . Please consult the documentation of your build tool how to configure your dependency resolving. We did this change to ensure that you do not accidentally get the new version. See the last section for the reason. The 1.0+ versions remain in our nexus as they are in the current state but will not get any updates. If you want to get newer versions of the mbeddr platform your have to change your dependency version. If you download your artefacts manually from the mbeddr Github page everything is the same as before but the version number is incremented. Other than that the artefacts didn't change and still contain the repackaged platform. We are planning to add a additional artefact that doesn't repackaged the MPS-extensions in the future to allow you more flexibility. MPS extension changes In the MPS extensions we only have additive changes. We added the mpsutil.grammarcells.* modules in that same state as they were in the mbeddr platform. You shouldn't observe any changes. In addition to that we kept the language ids to avoid any visible change for existing users of the languages. The version number of the MPS extensions remain in the normal scheme as documented above. Required changes for projects If your project is using grammar cells today it is using them through the mbeddr platform. If you do so you simply need to adjust the version number the dependency on the mbeddr platform and you are good to go. I your build scripts show errors after changing the dependency a simple \"reload modules from disk\" intention should be able to fix them. In case you currently only have dependency to the mbeddr platform because you want to use grammar cells you are now able to drop that dependency. To do so replace the dependency on the mbeddr platform with a dependency on the correct version of the MPS extensions. In this case you need to modify your MPS build scripts to no longer use the mbeddr platform as dependency but the MPS extensions. Afterwards MPS will complain that it can't find the dependency on the grammar cells languages in the build. To fix this invoke the \"reload modules from disk\" on the affected build script and the errors should go away.","title":"Home"},{"location":"#welcome-to-the-mps-extensions","text":"The MPS extensions aim to ease language development within MPS. They are maintained by itemis, JetBrains and the open source community and its development is closely related to the development of MPS.","title":"Welcome to the MPS Extensions"},{"location":"#mps-extensions-and-mbeddr-platform","text":"How is the relationship between the mbeddr (platform) and this project? The mbeddr project in the past developed a set of extensions that where used to allow easier development of languages with MPS. These extensions where not C specific and were called mbeddr platform . This project aims to give these extensions a new home. To make them more visible but also emphasise that these extensions are independent of mbeddr and it's C implementation in MPS. The midterm goal is to migrate most of these extensions in this project. Not all of them will really fit here because some of these are very experimental or have very specific use cases. Our goal is to migrate the stable bits first. See the migration section of the documentation on what we plan to migrate at the moment and how you could help.","title":"MPS Extensions and mbeddr (platform)"},{"location":"#getting-started","text":"To get started grab a release from our release page on github . Extract the archive and point a project or global library in MPS to the location where you extracted it. See the documentation regarding the individual extensions above. The documentation is \"currently work in progress\" as it being ported over from the mbeddr platform repository. Documentation related contributions are very welcome! We are also working on providing a zip file with all the sandboxes we have in our repository in order to try things out and see how the extensions work. See this issue for details .","title":"Getting Started"},{"location":"#artefacts-in-the-nexus","text":"We also provide the artefacts as a maven repository. Where you can fetch them during your CI build to setup your local development environment. Maven: project ... repositories repository id itemis.mbeddr /id url https://projects.itemis.de/nexus/content/repositories/mbeddr /url /repository /repositories dependencies ... dependency groupId de.itemis.mps /groupId artifactId extensions /artifactId version 2018.2 /version type zip /type /dependency /dependencies /project Gradle: repositories { maven { url 'https://projects.itemis.de/nexus/content/repositories/mbeddr' } } configurations { mpsExtensions } dependencies { mpsExtensions de.itemis.mps:extensions:2018.2.+ }","title":"Artefacts in the Nexus"},{"location":"#versions","text":"The version number reflects the MPS version the extensions are compatible with. For instance 2018.1.X is compatible with MPS 2018.1, 2017.3.X is compatible with MPS 2017.3.6. We only maintain compatibility with the latest minor release for each major version. While a 2017.3.x version of the extension might work with a on older version than MPS 2017.3.6 we only test it against the latest.","title":"Versions"},{"location":"#current-versions","text":"Currently these MPS versions are supported. Versions prior to MPS 2017.3 might still be available as the mbeddr platform but are not maintained in the repository. A version in maintenance will not get actively new features and is only maintained with bugfixes. We are happy to accept pull request for versions in maintenance with bugfixes but active feature development only happens for the latest MPS version. MPS Version State 2018.2 active development 2018.1 maintenance 2017.3 maintenance 2017.2 not maintained 2017.1 not maintained","title":"Current Versions"},{"location":"#grammar-cells-migration","text":"Starting from version 2018.2.348 the MPS extensions also contain grammar cells which have been ported over from the mbeddr platform. For users of grammar cells this is mostly a transparent change since the mbeddr platform currently repackages the MPS extensions. This means that if you are using the mbeddr platform today you should not have to do much manual work.","title":"Grammar Cells Migration"},{"location":"#mbeddr-changes","text":"The most obvious change here is that the version of the mbeddr artefacts was incremented by a minor. That means you will have to adjust your build files to get the version 1.1+ instead of 1.0* . Please consult the documentation of your build tool how to configure your dependency resolving. We did this change to ensure that you do not accidentally get the new version. See the last section for the reason. The 1.0+ versions remain in our nexus as they are in the current state but will not get any updates. If you want to get newer versions of the mbeddr platform your have to change your dependency version. If you download your artefacts manually from the mbeddr Github page everything is the same as before but the version number is incremented. Other than that the artefacts didn't change and still contain the repackaged platform. We are planning to add a additional artefact that doesn't repackaged the MPS-extensions in the future to allow you more flexibility.","title":"mbeddr changes"},{"location":"#mps-extension-changes","text":"In the MPS extensions we only have additive changes. We added the mpsutil.grammarcells.* modules in that same state as they were in the mbeddr platform. You shouldn't observe any changes. In addition to that we kept the language ids to avoid any visible change for existing users of the languages. The version number of the MPS extensions remain in the normal scheme as documented above.","title":"MPS extension changes"},{"location":"#required-changes-for-projects","text":"If your project is using grammar cells today it is using them through the mbeddr platform. If you do so you simply need to adjust the version number the dependency on the mbeddr platform and you are good to go. I your build scripts show errors after changing the dependency a simple \"reload modules from disk\" intention should be able to fix them. In case you currently only have dependency to the mbeddr platform because you want to use grammar cells you are now able to drop that dependency. To do so replace the dependency on the mbeddr platform with a dependency on the correct version of the MPS extensions. In this case you need to modify your MPS build scripts to no longer use the mbeddr platform as dependency but the MPS extensions. Afterwards MPS will complain that it can't find the dependency on the grammar cells languages in the build. To fix this invoke the \"reload modules from disk\" on the affected build script and the errors should go away.","title":"Required changes for projects"},{"location":"Migrating/","text":"Migrating an Extension from the mbeddr Platform There are two different kinds of migrating a extension from the mbeddr platform to the MPS-Extensions: The extension already exists as a separate plugin in the mbeddr platform The extension is currently part of the big com.mbeddr.mpsutil plugin A list of the first (easier) to migrate extension is here . Migrating extension of that list is pretty straight forward: Check the Dependencies First of all check if all dependencies are already migrated to this repository. If you not you can't migrate the extension. To do so open the com.mbeddr.build project in the mbeddr repository. Click the link in the issue that is related to the extension to select the corresponding plugin in the build script. You will see something like this: idea plugin com.mbeddr.mpsutil.jung name com.mbeddr.mpsutil.jung short (folder) name com.mbeddr.mpsutil.jung description no description version ${mbeddr.version} no vendor content: group.jung dependencies: jetbrains.mps.core ... First of all check the dependencies section of the plugin if it contains plugins that start with com.meddr then it still has dependencies and cannot be moved. Though you might want to move the plugin it depends. \ud83d\ude09 Move the Files If all dependencies are already part of the MPS-extensions we can start with migrating the extension. Follow the reference(s) in the content section. group.jung in this case: mps group group.jung solution com.mbeddr.mpsutil.jung.pluginSolution load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/solutions/pluginSolution/com.mbeddr.mpsutil.jung.pluginSolution.msd language com.mbeddr.mpsutil.jung load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/com.mbeddr.mpsutil.jung.mpl Both of modules in the plugin are located under the code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung directory. The first thing to do is create a folder in the MPS-extensions repository where we can place these files. This folder should be placed in under the code directory of the MPS-Extensions repository. The naming convention is that it shall contain the last name of the namespace . In this case jung . All the files from the mbeddr repository code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung are copied over to code/jung/lanugages in the MPS-extensions repository. The structure in the MPS-extensions repository slightly differs from the one in mbeddr. That requires an additional step. Some languages contain a dedicated solutions folder next to the language. We don't use this kind of file layout in the MPS-extensions repository. In theses cases the file from code/jung/lanugages/solutions need to get moved to code/jung/solutions . Sounds too complicated? Don't worry we will help you when sent the pull request to get it right. \ud83d\ude09 Adding the Files to the Project The files need to be part of the MPS project to show up in MPS. This is done by adding them to the project path: And then selecting the before copied files: The files end up in no folder in the project by default. They should be placed in a virtual folder of the project matches subfolder in code . In this case jung : After this is done the last step that is missing is adding the plugin to the build. Adding it to the Build To build plugin that was moved it needs to beb part of the build scripts. These scripts are located under the build folder of the project. The solution of interest is de.itemis.mps.extensions.build . And then the de.itemis.mps.extensions build project: The first thing required is a group where all the implementation modules of the plugin are places. Tests are placed in a different script. The group is named similar to the mbeddr group name but the prefix is not com.mbeddr.mpsutil but de.itemis.mps . In this case this results to de.itemis.mps.jung . This group then contains all the the solutions and languages of the plugin: After the group is created a idea plugin is required. This plugin references the group and should be placed right above the group in the build script. This is very important to keep the build script maintainable. The final step is adding the plugin to the layout section of the build project. After adding the plugin to the layout it should be possible to build the model. But in most cases a error like this will be shown: cannot build relative path to `wstx-asl-3.2.6.jar': No such path in local layout -- -- was input node: [path] BuildSourceMacroRelativePath null[8622958246116067669] in de.itemis.mps.extensions.build@5_1 -- was template node: r:54537613-52b5-40a8-b223-e87f0960b04f(jetbrains.mps.build.mps.generator.template.main@generator)/4743026300739052425 This error message means that some jar files that are used by the language or some solution are missing. The convention here is to create a lib folder in the plugin and include the required jar files. These files are usually contained in a lib folder. Sending the Pull Request To verify that everything works correctly run: ./gradlew test # mac OS / Linux gradlew.bat test # Windows This command should finish successfully. After that please create pull request at out repository and label it with migration If something doesn't work out quite well or you are unsure what to do don't worry. You can still send the PR and somebody will guide you through the process. Bonus If you are really eager you can send a PR to the mbeddr platform repository that removed the plugin there.","title":"Migrating"},{"location":"Migrating/#migrating-an-extension-from-the-mbeddr-platform","text":"There are two different kinds of migrating a extension from the mbeddr platform to the MPS-Extensions: The extension already exists as a separate plugin in the mbeddr platform The extension is currently part of the big com.mbeddr.mpsutil plugin A list of the first (easier) to migrate extension is here . Migrating extension of that list is pretty straight forward:","title":"Migrating an Extension from the mbeddr Platform"},{"location":"Migrating/#check-the-dependencies","text":"First of all check if all dependencies are already migrated to this repository. If you not you can't migrate the extension. To do so open the com.mbeddr.build project in the mbeddr repository. Click the link in the issue that is related to the extension to select the corresponding plugin in the build script. You will see something like this: idea plugin com.mbeddr.mpsutil.jung name com.mbeddr.mpsutil.jung short (folder) name com.mbeddr.mpsutil.jung description no description version ${mbeddr.version} no vendor content: group.jung dependencies: jetbrains.mps.core ... First of all check the dependencies section of the plugin if it contains plugins that start with com.meddr then it still has dependencies and cannot be moved. Though you might want to move the plugin it depends. \ud83d\ude09","title":"Check the Dependencies"},{"location":"Migrating/#move-the-files","text":"If all dependencies are already part of the MPS-extensions we can start with migrating the extension. Follow the reference(s) in the content section. group.jung in this case: mps group group.jung solution com.mbeddr.mpsutil.jung.pluginSolution load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/solutions/pluginSolution/com.mbeddr.mpsutil.jung.pluginSolution.msd language com.mbeddr.mpsutil.jung load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/com.mbeddr.mpsutil.jung.mpl Both of modules in the plugin are located under the code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung directory. The first thing to do is create a folder in the MPS-extensions repository where we can place these files. This folder should be placed in under the code directory of the MPS-Extensions repository. The naming convention is that it shall contain the last name of the namespace . In this case jung . All the files from the mbeddr repository code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung are copied over to code/jung/lanugages in the MPS-extensions repository. The structure in the MPS-extensions repository slightly differs from the one in mbeddr. That requires an additional step. Some languages contain a dedicated solutions folder next to the language. We don't use this kind of file layout in the MPS-extensions repository. In theses cases the file from code/jung/lanugages/solutions need to get moved to code/jung/solutions . Sounds too complicated? Don't worry we will help you when sent the pull request to get it right. \ud83d\ude09","title":"Move the Files"},{"location":"Migrating/#adding-the-files-to-the-project","text":"The files need to be part of the MPS project to show up in MPS. This is done by adding them to the project path: And then selecting the before copied files: The files end up in no folder in the project by default. They should be placed in a virtual folder of the project matches subfolder in code . In this case jung : After this is done the last step that is missing is adding the plugin to the build.","title":"Adding the Files to the Project"},{"location":"Migrating/#adding-it-to-the-build","text":"To build plugin that was moved it needs to beb part of the build scripts. These scripts are located under the build folder of the project. The solution of interest is de.itemis.mps.extensions.build . And then the de.itemis.mps.extensions build project: The first thing required is a group where all the implementation modules of the plugin are places. Tests are placed in a different script. The group is named similar to the mbeddr group name but the prefix is not com.mbeddr.mpsutil but de.itemis.mps . In this case this results to de.itemis.mps.jung . This group then contains all the the solutions and languages of the plugin: After the group is created a idea plugin is required. This plugin references the group and should be placed right above the group in the build script. This is very important to keep the build script maintainable. The final step is adding the plugin to the layout section of the build project. After adding the plugin to the layout it should be possible to build the model. But in most cases a error like this will be shown: cannot build relative path to `wstx-asl-3.2.6.jar': No such path in local layout -- -- was input node: [path] BuildSourceMacroRelativePath null[8622958246116067669] in de.itemis.mps.extensions.build@5_1 -- was template node: r:54537613-52b5-40a8-b223-e87f0960b04f(jetbrains.mps.build.mps.generator.template.main@generator)/4743026300739052425 This error message means that some jar files that are used by the language or some solution are missing. The convention here is to create a lib folder in the plugin and include the required jar files. These files are usually contained in a lib folder.","title":"Adding it to the Build"},{"location":"Migrating/#sending-the-pull-request","text":"To verify that everything works correctly run: ./gradlew test # mac OS / Linux gradlew.bat test # Windows This command should finish successfully. After that please create pull request at out repository and label it with migration If something doesn't work out quite well or you are unsure what to do don't worry. You can still send the PR and somebody will guide you through the process.","title":"Sending the Pull Request"},{"location":"Migrating/#bonus","text":"If you are really eager you can send a PR to the mbeddr platform repository that removed the plugin there.","title":"Bonus"},{"location":"building/","text":"Building The MPS extension are build using gradle. In order to build the source code all you need on the machine is a Java 8 JDK. Of course if you want to hack on the MPS extension you need MPS. The MPS version that is currently used is in our build.gradle file. In order to build the project run: ./gradlew # Mac and Linux gradlew.bat # Windows This will fetch the required MPS version from the internet so you need to be online when first execute the build. The default task does not run the test when building if you want to execute the tests then run: ./gradlew run_tests # Mac and Linux gradlew.bat run_tests # Windows","title":"Building"},{"location":"building/#building","text":"The MPS extension are build using gradle. In order to build the source code all you need on the machine is a Java 8 JDK. Of course if you want to hack on the MPS extension you need MPS. The MPS version that is currently used is in our build.gradle file. In order to build the project run: ./gradlew # Mac and Linux gradlew.bat # Windows This will fetch the required MPS version from the internet so you need to be online when first execute the build. The default task does not run the test when building if you want to execute the tests then run: ./gradlew run_tests # Mac and Linux gradlew.bat run_tests # Windows","title":"Building"},{"location":"contributing/","text":"Contributing Contributes are always welcome, no matter if it's additional documentation, a bugfix, a new feature to an existing extension or complete new extension that you are adding to the repository. If you are looking for an easy first contribution have a look at this list. Currently one of the biggest tasks we are working on is migrating some of the extensions from the mbeddr platform to this repository. If you like to help have a look at this page . Should you not feel comfortable to start with a code contribution additions to our documentation are always very welcome. Our documentation is in this repository as well. You can have edit it in your browser right a way if you like. For bugfixes, documentation and small new features you can open a pull request right away. Bigger features or new extensions should get some discussion in an issue just to make sure we are all on the same page about what is going to be done. If you are unsure what to do don't hesitate to open a issue and ask for help.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributes are always welcome, no matter if it's additional documentation, a bugfix, a new feature to an existing extension or complete new extension that you are adding to the repository. If you are looking for an easy first contribution have a look at this list. Currently one of the biggest tasks we are working on is migrating some of the extensions from the mbeddr platform to this repository. If you like to help have a look at this page . Should you not feel comfortable to start with a code contribution additions to our documentation are always very welcome. Our documentation is in this repository as well. You can have edit it in your browser right a way if you like. For bugfixes, documentation and small new features you can open a pull request right away. Bigger features or new extensions should get some discussion in an issue just to make sure we are all on the same page about what is going to be done. If you are unsure what to do don't hesitate to open a issue and ask for help.","title":"Contributing"},{"location":"extensions/diagrams/","text":"Diagrams Language Namespace : de.itemis.mps.editor.diagram If you have downloaded the recent mbeddr master branch, you will have noticed that, for example, component wiring and state machines can now be edited graphically. The screenshots below show examples of these two notations. This screenshot shows a few interesting features: you can embed diagrams anywhere in \"text\", you can use different shapes (at this point drawn by custom Java code), you can use various line styles, the framework supports ports (i.e., connection endpoints on the boxes), inside boxes you can use arbitrary MPS text (or other) editors, and the system also supports edge and endpoint labels. Port labels are also supported, but they are only shown if the mouse is \"in the vicinity\" of the port to not clutter the diagram. Below is a second screenshot of a bigger diagram: This one illustrates that the approach scales to reasonable sizes, shows that zooming is supported and also demonstrates the auto layouting capability. The graphical notation also integrates with things such as tooltips. Below is another example diagram that shows a different language: The definition of a graphical editor is based on the same \"cell\" abstraction used in other MPS editors: the language for defining editors contains additional cells that are then rendered as a diagram (diagram, diagram.box, diagram.edge). Similar to tables, these abstractions for defining graphical editors rely on queries to make sure that the structure of the graphical editor does not have to directly correspond to the structure of the AST (for example, in terms of ownership). The language also supports hierarchical diagrams, for example, in state machines. To see example code, check out InstanceConfiguration and Statemachine. The diagram notation is relatively sophisticated and requires much more documentation than what we can provide right now on this page. More will follow later.","title":"Diagrams"},{"location":"extensions/diagrams/#diagrams","text":"Language Namespace : de.itemis.mps.editor.diagram If you have downloaded the recent mbeddr master branch, you will have noticed that, for example, component wiring and state machines can now be edited graphically. The screenshots below show examples of these two notations. This screenshot shows a few interesting features: you can embed diagrams anywhere in \"text\", you can use different shapes (at this point drawn by custom Java code), you can use various line styles, the framework supports ports (i.e., connection endpoints on the boxes), inside boxes you can use arbitrary MPS text (or other) editors, and the system also supports edge and endpoint labels. Port labels are also supported, but they are only shown if the mouse is \"in the vicinity\" of the port to not clutter the diagram. Below is a second screenshot of a bigger diagram: This one illustrates that the approach scales to reasonable sizes, shows that zooming is supported and also demonstrates the auto layouting capability. The graphical notation also integrates with things such as tooltips. Below is another example diagram that shows a different language: The definition of a graphical editor is based on the same \"cell\" abstraction used in other MPS editors: the language for defining editors contains additional cells that are then rendered as a diagram (diagram, diagram.box, diagram.edge). Similar to tables, these abstractions for defining graphical editors rely on queries to make sure that the structure of the graphical editor does not have to directly correspond to the structure of the AST (for example, in terms of ownership). The language also supports hierarchical diagrams, for example, in state machines. To see example code, check out InstanceConfiguration and Statemachine. The diagram notation is relatively sophisticated and requires much more documentation than what we can provide right now on this page. More will follow later.","title":"Diagrams"},{"location":"extensions/node-versioning/","text":"Node Versioning Language Namespace : de.itemis.mps.nodeversioning The node versioning extension gives support for storing different states/versions of a node inside of the model. It is not a replacement for version control systems like git . An example use case might be a model is used to describe an API and the users wants to detect changes between different releases of the API. This API has a version number that follows semVer associated with it. Now when users wants check what changes happened since the last release the information stored by this extension can be used to diff the current state against the last released one. The scope of this extension is to provide a way to store the versions of a node and do change detection. It does intentionally not provide ways how to semantically reason about a change as this is highly domain specific. It might be used in conjunction with the nodecomparator to do structural diffs between versions. State: Incubating This extension is currently incubating and might under go substantial changes in the future. Currently it only supports storing of the version information and change detection. For future feature ideas see the potential features section. What is a Node When we speak of a node in this document we mean the node and all of its children but not of the referenced nodes. Sometimes this is also called subtree . When we speak of the dependencies of a node we mean all nodes that are referenced by either node itself or it children. Meta Model The version information is stored on the node that is versioned as a NodeAttribute called NodeVersion . The NodeVersion contains a copy of the node at point in time when the version was created. In addition to the copy it also stores a VersionNumber which is a simple integer incremented with each version that is created. The VersionNumber has no other semantics than to provide ordering to the versions. To be able to detect changes of a node it also stores a hash of the node. The NodeVersion also contains a list of all the dependencies (reference targets) of the node and its version, these are called LinkVersion . Change Detection On first glance change detection looks pretty straight forward. A node has changed when either the node itself has changed or one of the dependencies: But if we at MPS models they are not simple tree but graphs that allow reference cycles. In this cases we cannot simply traverse the complete graph over the edges since we would end up in a cycle. Imagine model like this: In this case the change detection has to take into account that there is a cycle from 5 -- 4 -- 6 -- 5 . The change detection algorithm detects this cycle and handles them appropriately. If none of the participants in a cycle have local changes then the whole cycle is assumed to be unchanged. Technically the detection if a node has changed since the last time it has been versioned is done via hashing. If the hash differs from the hash calculated for the last version then the node has changed. The current implementation uses SHA 1 hashes to verify if the node has changed. Potential Features time travel : Getting the model back into the exact same state as it was when a specific version on a node was created. Most likely as some kind of transient model that is not visible to the user. Referencing nodes in a specific version. While this to some degree already happens behind the scenes. It might be useful for the user to implement an API in specific version. Delete handling. At the moment when the user deletes a node that is still referenced from some other node in an older version (that is potentially not visible to the user) the model is in a broken state. Usage The general pattern that all functionally of the nodeversioning extension that all parts follow is that it will never mutate the model during its execution. It will collect changes or calculate a new set of NodeVersions but its up to the user of the extension to actually mutate the model. This behaviour is due to the fact that the domain requires human interaction to review the changes and allow to veto based on that review. First of all models that should get versioned need to use the de.itemis.mps.nodeversioning language. Most probably you want to expose this to the end user through a DevKit. This language does not add anything the user can see or interact with but adds the NodeAttribute s required for the versioning. In order to version a model or otherwise interact with the versions stored in the nodes use the de.itemis.mps.nodeversioning.runtime solution. The class you want to have a look at is VersioningHelper it provides the methods to version a node or check if something has changed. For more details see the JavaDoc on that class.","title":"Node Versioning"},{"location":"extensions/node-versioning/#node-versioning","text":"Language Namespace : de.itemis.mps.nodeversioning The node versioning extension gives support for storing different states/versions of a node inside of the model. It is not a replacement for version control systems like git . An example use case might be a model is used to describe an API and the users wants to detect changes between different releases of the API. This API has a version number that follows semVer associated with it. Now when users wants check what changes happened since the last release the information stored by this extension can be used to diff the current state against the last released one. The scope of this extension is to provide a way to store the versions of a node and do change detection. It does intentionally not provide ways how to semantically reason about a change as this is highly domain specific. It might be used in conjunction with the nodecomparator to do structural diffs between versions. State: Incubating This extension is currently incubating and might under go substantial changes in the future. Currently it only supports storing of the version information and change detection. For future feature ideas see the potential features section.","title":"Node Versioning"},{"location":"extensions/node-versioning/#what-is-a-node","text":"When we speak of a node in this document we mean the node and all of its children but not of the referenced nodes. Sometimes this is also called subtree . When we speak of the dependencies of a node we mean all nodes that are referenced by either node itself or it children.","title":"What is a Node"},{"location":"extensions/node-versioning/#meta-model","text":"The version information is stored on the node that is versioned as a NodeAttribute called NodeVersion . The NodeVersion contains a copy of the node at point in time when the version was created. In addition to the copy it also stores a VersionNumber which is a simple integer incremented with each version that is created. The VersionNumber has no other semantics than to provide ordering to the versions. To be able to detect changes of a node it also stores a hash of the node. The NodeVersion also contains a list of all the dependencies (reference targets) of the node and its version, these are called LinkVersion .","title":"Meta Model"},{"location":"extensions/node-versioning/#change-detection","text":"On first glance change detection looks pretty straight forward. A node has changed when either the node itself has changed or one of the dependencies: But if we at MPS models they are not simple tree but graphs that allow reference cycles. In this cases we cannot simply traverse the complete graph over the edges since we would end up in a cycle. Imagine model like this: In this case the change detection has to take into account that there is a cycle from 5 -- 4 -- 6 -- 5 . The change detection algorithm detects this cycle and handles them appropriately. If none of the participants in a cycle have local changes then the whole cycle is assumed to be unchanged. Technically the detection if a node has changed since the last time it has been versioned is done via hashing. If the hash differs from the hash calculated for the last version then the node has changed. The current implementation uses SHA 1 hashes to verify if the node has changed.","title":"Change Detection"},{"location":"extensions/node-versioning/#potential-features","text":"time travel : Getting the model back into the exact same state as it was when a specific version on a node was created. Most likely as some kind of transient model that is not visible to the user. Referencing nodes in a specific version. While this to some degree already happens behind the scenes. It might be useful for the user to implement an API in specific version. Delete handling. At the moment when the user deletes a node that is still referenced from some other node in an older version (that is potentially not visible to the user) the model is in a broken state.","title":"Potential Features"},{"location":"extensions/node-versioning/#usage","text":"The general pattern that all functionally of the nodeversioning extension that all parts follow is that it will never mutate the model during its execution. It will collect changes or calculate a new set of NodeVersions but its up to the user of the extension to actually mutate the model. This behaviour is due to the fact that the domain requires human interaction to review the changes and allow to veto based on that review. First of all models that should get versioned need to use the de.itemis.mps.nodeversioning language. Most probably you want to expose this to the end user through a DevKit. This language does not add anything the user can see or interact with but adds the NodeAttribute s required for the versioning. In order to version a model or otherwise interact with the versions stored in the nodes use the de.itemis.mps.nodeversioning.runtime solution. The class you want to have a look at is VersioningHelper it provides the methods to version a node or check if something has changed. For more details see the JavaDoc on that class.","title":"Usage"}]}